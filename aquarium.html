<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tickerquarium</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: radial-gradient(circle at 50% 30%, #002244, #000820);
        height: 100%;
        width: 100%;
        font-family: sans-serif;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #aaf;
        background: rgba(0, 0, 30, 0.4);
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <canvas id="aquarium"></canvas>
    <div id="info">ðŸ’¬ Tickerquarium: Wer postet, schwimmt!</div>

    <script>
      const canvas = document.getElementById('aquarium')
      const ctx = canvas.getContext('2d')

      let users = {}
      const inactivityLimit = 3600 * 1000

      let lastWidth = window.innerWidth
      let lastHeight = window.innerHeight

      function resize() {
        const newWidth = window.innerWidth
        const newHeight = window.innerHeight

        // Scale fish positions to new size
        const scaleX = newWidth / lastWidth
        const scaleY = newHeight / lastHeight

        for (const fish of Object.values(users)) {
          fish.x *= scaleX
          fish.y *= scaleY
        }

        canvas.width = newWidth
        canvas.height = newHeight
        lastWidth = newWidth
        lastHeight = newHeight
      }

      window.addEventListener('resize', resize)
      resize()

      function randomColor() {
        return `hsl(${Math.random() * 360}, 70%, 60%)`
      }

      function drawFish(fish) {
        ctx.save()
        ctx.translate(fish.x, fish.y)
        ctx.scale(fish.direction, 1)

        // Draw body
        ctx.fillStyle = fish.color
        ctx.beginPath()
        ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2)
        ctx.fill()

        // Tail
        ctx.beginPath()
        ctx.moveTo(-20, 0)
        ctx.lineTo(-30, -10)
        ctx.lineTo(-30, 10)
        ctx.closePath()
        ctx.fill()

        // Optional glow for recent activity
        const glowStrength = Math.max(0, 1 - (Date.now() - fish.lastActive) / 5000)
        if (glowStrength > 0) {
          ctx.shadowColor = fish.color
          ctx.shadowBlur = 15 * glowStrength
          ctx.beginPath()
          ctx.arc(0, 0, 10 + 10 * glowStrength, 0, Math.PI * 2)
          ctx.fill()
          ctx.shadowBlur = 0
        }

        ctx.restore()

        // --- Draw username label ---
        ctx.font = '14px sans-serif'
        ctx.textAlign = 'center'
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)'
        ctx.fillText(fish.name, fish.x, fish.y - 18) // draw above the fish
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        const now = Date.now()

        for (const [name, fish] of Object.entries(users)) {
          const inactive = now - fish.lastActive > inactivityLimit

          if (inactive) {
            // Swim off-screen slowly
            fish.x += fish.direction * 1.5
            if (fish.x < -60 || fish.x > canvas.width + 60) {
              delete users[name]
              continue
            }
          } else {
            // Swim pattern
            fish.x += fish.direction * fish.speed
            fish.y += Math.sin(Date.now() / 700 + fish.offset) * 0.5

            // Bounce off walls
            if (fish.x < 30) fish.direction = 1
            if (fish.x > canvas.width - 30) fish.direction = -1

            fish.y = Math.min(Math.max(30, fish.y), canvas.height - 30)
          }

          drawFish(fish)
        }

        requestAnimationFrame(animate)
      }

      function handlePost(user) {
        if (!users[user]) {
          users[user] = {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            direction: Math.random() < 0.5 ? 1 : -1,
            color: randomColor(),
            offset: Math.random() * Math.PI * 2,
            speed: 0.5 + Math.random() * 0.5,
            lastActive: Date.now(),
            name: user,
          }
        } else {
          users[user].lastActive = Date.now()
        }
      }

      // Sleep for `ms` milliseconds.
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms))
      }

      // Retry fetch with exponential backoff: scale * base**n * (1 + jitter * RANDOM)
      async function retryFetch(url, maxRetries = 10, base = 2, scale = 1000, jitter = 0.2) {
        for (let i = 0; i < maxRetries; i++) {
          try {
            const result = await fetch(url)
            if (result.ok) return result
          } catch (err) {
            console.error(err)
          }

          let delay = scale * base ** i * (1 + jitter * Math.random())
          console.warn(`Request failed. Retrying in ${delay} ms...`)
          await sleep(delay)
        }

        throw new Error('Request failed')
      }

      const TICKER_ID = 3000000285971

      // Keep timestamps for user activity. We use this to detect connection timeouts.
      // The connection is reset if no activity is detected for
      // TIMEOUT_FACTOR * AVERAGE_INTERVAL or MIN_TIMEOUT.
      const MAX_TIMESTAMPS = 20
      const MIN_TIMEOUT = 600 * 1000
      const TIMEOUT_FACTOR = 5
      const userActivities = []

      const corsAnywhere = 'https://cors-anywhere.com/'
      const hubUrl = 'https://live.derstandard.at/jetzt/signalr/hub'

      async function connectWebsocket() {
        connectionData = await retryFetch(corsAnywhere + hubUrl + '/negotiate')
        connectionJson = await connectionData.json()

        payload = {
          transport: 'webSockets',
          clientProtocol: '1.5',
          lbid: TICKER_ID,
          v: '1.0.8907.26570',
          connectionToken: connectionJson.ConnectionToken,
          connectionData: '[{"name": "reporthub"}]',
          tid: '10',
        }

        connectUrl = new URL(hubUrl + '/connect')
        connectUrl.protocol = 'wss:'
        connectUrl = connectUrl + '?' + new URLSearchParams(payload)

        const ws = new WebSocket(connectUrl)
        ws.onmessage = (event) => {
          data = JSON.parse(event.data)
          for (let ea of data.M || []) {
            if (ea.M == 'addPostings' || ea.M == 'updateVotes') {
              userActivities.push(Date.now())
              if (userActivities.length > MAX_TIMESTAMPS) userActivites.shift()
            }

            if (ea.M != 'addPostings') continue

            for (let eb of ea.A || []) {
              for (ec of eb) {
                console.info('User activity:', ec.cn)
                handlePost(ec.cn)
              }
            }
          }
        }
        ws.onopen = async (event) => {
          startUrl = new URL(corsAnywhere + hubUrl + '/start')
          startUrl = startUrl + '?' + new URLSearchParams(payload)
          await retryFetch(startUrl)
        }
        ws.onclose = async () => {
          console.warn('Connection closed. Reconnecting in 10s...')
          setTimeout(connectWebsocket, 10000)
        }
        return ws
      }

      // Establish the initial connectino to the ticker.
      let webSocket = null
      connectWebsocket().then((ws) => {
        webSocket = ws
      })

      // Check for timeouts every few seconds.
      setInterval(async () => {
        let lastActivity = Infinity
        if (userActivities.length) {
          lastActivity = userActivities[userActivities.length - 1]
        }

        let averageInterval = 0
        for (let i = 0; i < userActivities.length - 1; i++) {
          averageInterval += userActivities[i + 1] - userActivities[i]
        }
        averageInterval /= userActivities.length - 1

        let timeout = MIN_TIMEOUT
        if (isFinite(averageInterval)) {
          timeout = Math.max(MIN_TIMEOUT, averageInterval * TIMEOUT_FACTOR)
        }

        if (webSocket == null) {
          // If for some reason the initial connection wasn't established and the web socket is still null,
          // we connect it now. This shouldn't happen.
          console.warn('Connection not established. Connecting now...')
          webSocket = await connectWebsocket()
        } else if (Date.now() > lastActivity + timeout) {
          console.warn('Connection timed out. Closing...')
          webSocket.close()
          webSocket = null
        }
      }, 10 * 1000)

      animate()
    </script>
  </body>
</html>
